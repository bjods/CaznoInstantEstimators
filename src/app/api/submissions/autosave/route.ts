import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase'

interface AutosaveData {
  sessionId: string
  widgetId: string
  formData: Record<string, any>
  currentStep?: string
  stepCompleted?: boolean
}

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
  'Access-Control-Allow-Headers': 'Content-Type, Authorization',
}

export async function OPTIONS() {
  return NextResponse.json({}, { headers: corsHeaders })
}

async function queueSMSNotification(
  supabase: any,
  businessId: string,
  submissionId: string,
  messageType: string,
  templateData: Record<string, any>
) {
  try {
    // Get business SMS phone numbers
    const { data: business, error: businessError } = await supabase
      .from('businesses')
      .select('sms_phone_numbers')
      .eq('id', businessId)
      .single()

    if (businessError || !business?.sms_phone_numbers) {
      console.log('No SMS phone numbers configured for business:', businessId)
      return
    }

    const phoneNumbers = Array.isArray(business.sms_phone_numbers) 
      ? business.sms_phone_numbers 
      : [business.sms_phone_numbers]

    // Queue SMS for each phone number
    for (const phoneNumber of phoneNumbers) {
      if (phoneNumber && phoneNumber.trim()) {
        const { error: queueError } = await supabase
          .from('sms_queue')
          .insert({
            business_id: businessId,
            submission_id: submissionId,
            recipient_phone: phoneNumber.trim(),
            recipient_name: 'Business Owner',
            message: '', // Will be generated by edge function
            message_type: messageType,
            template_data: templateData,
            status: 'pending',
            next_retry_at: new Date().toISOString()
          })

        if (queueError) {
          console.error('Failed to queue SMS:', queueError)
        } else {
          console.log(`Queued ${messageType} SMS for ${phoneNumber}`)
        }
      }
    }

    // Trigger SMS processing
    try {
      const functionUrl = `${process.env.NEXT_PUBLIC_SUPABASE_URL}/functions/v1/send-sms`
      const response = await fetch(functionUrl, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${process.env.SUPABASE_SERVICE_ROLE_KEY}`,
          'Content-Type': 'application/json',
        },
      })

      if (!response.ok) {
        console.error('Failed to trigger SMS function:', await response.text())
      }
    } catch (triggerError) {
      console.error('Failed to trigger SMS function:', triggerError)
      // Don't fail the submission if SMS trigger fails
    }
  } catch (error) {
    console.error('Error in queueSMSNotification:', error)
  }
}

export async function POST(request: NextRequest) {
  try {
    const supabase = createClient()
    const body: AutosaveData = await request.json()
    
    const { sessionId, widgetId, formData, currentStep, stepCompleted } = body

    // Get widget and business info
    const { data: widget, error: widgetError } = await supabase
      .from('widgets')
      .select('id, business_id, config')
      .eq('id', widgetId)
      .single()

    if (widgetError || !widget) {
      return NextResponse.json(
        { success: false, error: 'Widget not found' },
        { status: 404, headers: corsHeaders }
      )
    }

    // Extract contact info for indexed fields
    const email = formData.email || null
    const phone = formData.phone || null
    const fullName = formData.name || 
      (formData.firstName && formData.lastName ? `${formData.firstName} ${formData.lastName}` : null)
    const address = formData.address || null

    // Determine completion status
    let completionStatus = 'partial'
    const hasPersonalInfo = email && phone && fullName
    
    if (hasPersonalInfo) {
      completionStatus = 'captured'
    }

    // Check if this is a complete submission (all steps completed)
    const totalSteps = widget.config?.steps?.length || 0
    const isComplete = stepCompleted && currentStep === `step-${totalSteps - 1}`
    
    if (isComplete) {
      completionStatus = 'complete'
    }

    // Prepare submission data
    const submissionData = {
      session_id: sessionId,
      widget_id: widgetId,
      business_id: widget.business_id,
      email,
      phone,
      full_name: fullName,
      address,
      form_data: formData,
      contact_data: {
        firstName: formData.firstName,
        lastName: formData.lastName,
        email: formData.email,
        phone: formData.phone,
        address: formData.address
      },
      completion_status: completionStatus,
      last_step_completed: currentStep,
      total_steps: totalSteps,
      source: 'widget',
      user_agent: request.headers.get('user-agent') || null,
      personal_info_completed_at: hasPersonalInfo ? new Date().toISOString() : null,
      estimate_completed_at: isComplete ? new Date().toISOString() : null
    }

    // Upsert submission (insert or update based on session_id)
    const { data: submission, error: submissionError } = await supabase
      .from('submissions')
      .upsert(
        submissionData,
        { 
          onConflict: 'session_id',
          ignoreDuplicates: false 
        }
      )
      .select()
      .single()

    if (submissionError) {
      console.error('Failed to save submission:', submissionError)
      return NextResponse.json(
        { success: false, error: 'Failed to save submission' },
        { status: 500, headers: corsHeaders }
      )
    }

    // If personal info just completed, handle notifications
    if (completionStatus === 'captured' && hasPersonalInfo) {
      // Queue SMS notification for business
      const smsConfig = widget.config?.notifications?.sms
      if (smsConfig?.enabled && smsConfig.send_lead_captured) {
        await queueSMSNotification(
          supabase,
          widget.business_id,
          submission.id,
          'lead_captured',
          {
            name: fullName,
            email,
            phone,
            address,
            service: Array.isArray(formData.service) 
              ? formData.service.join(', ') 
              : (formData.service || 'Not specified'),
            widgetName: widget.config?.name || 'Instant Estimator',
            timestamp: new Date().toLocaleString()
          }
        )
      }
    }

    return NextResponse.json({
      success: true,
      data: {
        submissionId: submission.id,
        sessionId: submission.session_id,
        completionStatus: submission.completion_status,
        saved: true
      }
    }, { headers: corsHeaders })

  } catch (error) {
    console.error('Autosave error:', error)
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500, headers: corsHeaders }
    )
  }
}